
const express = require('express');
const fs = require('fs');
const path = require('path');
const axios = require('axios');

class CRMRouteValidator {
  constructor(baseUrl = 'http://0.0.0.0:3000') {
    this.baseUrl = baseUrl;
    this.errors = [];
    this.warnings = [];
    this.validatedRoutes = new Set();
    this.staticFiles = new Set();
  }

  // üîç VALIDAR TODAS LAS RUTAS API
  async validateAPIRoutes() {
    console.log('üîç Validando rutas API del CRM...\n');
    
    const apiRoutes = [
      // Rutas de autenticaci√≥n
      { method: 'POST', path: '/api/auth/login', requiresAuth: false },
      { method: 'POST', path: '/api/auth/register', requiresAuth: false },
      { method: 'GET', path: '/api/ping', requiresAuth: false },
      
      // Rutas principales (requieren auth)
      { method: 'GET', path: '/api/clients', requiresAuth: true },
      { method: 'POST', path: '/api/clients', requiresAuth: true },
      { method: 'GET', path: '/api/quotations', requiresAuth: true },
      { method: 'POST', path: '/api/quotations', requiresAuth: true },
      { method: 'GET', path: '/api/leads', requiresAuth: true },
      { method: 'POST', path: '/api/leads', requiresAuth: true },
      { method: 'GET', path: '/api/followups', requiresAuth: true },
      { method: 'POST', path: '/api/followups', requiresAuth: true },
      { method: 'GET', path: '/api/dashboard', requiresAuth: true },
      { method: 'GET', path: '/api/users', requiresAuth: true },
      { method: 'GET', path: '/api/roles', requiresAuth: true },
      { method: 'GET', path: '/api/apikeys', requiresAuth: true },
      { method: 'POST', path: '/api/apikeys', requiresAuth: true },
      { method: 'GET', path: '/api/notifications', requiresAuth: true },
      { method: 'GET', path: '/api/subscriptions', requiresAuth: true },
      { method: 'GET', path: '/api/analytics', requiresAuth: true },
      { method: 'GET', path: '/api/automation', requiresAuth: true },
      { method: 'GET', path: '/api/custom-fields', requiresAuth: true },
      { method: 'GET', path: '/api/contactos-telefonicos', requiresAuth: true },
      { method: 'GET', path: '/api/account', requiresAuth: true },
      { method: 'POST', path: '/api/supabase-clients', requiresAuth: false },
      { method: 'POST', path: '/api/webhook', requiresAuth: false },
      { method: 'GET', path: '/api/resumen', requiresAuth: true },
      { method: 'GET', path: '/api/debug', requiresAuth: true }
    ];

    for (const route of apiRoutes) {
      await this.testAPIRoute(route);
    }
  }

  async testAPIRoute(route) {
    try {
      const url = `${this.baseUrl}${route.path}`;
      const config = {
        method: route.method,
        timeout: 5000,
        validateStatus: (status) => status < 500 // Aceptar c√≥digos de error esperados
      };

      // Para rutas que requieren auth, probar sin token primero
      if (route.requiresAuth) {
        try {
          const response = await axios(url, config);
          if (response.status === 401) {
            console.log(`‚úÖ ${route.method} ${route.path} - Protegida correctamente (401)`);
          } else {
            this.warnings.push(`‚ö†Ô∏è  ${route.method} ${route.path} - Deber√≠a requerir autenticaci√≥n pero devuelve ${response.status}`);
          }
        } catch (error) {
          if (error.code === 'ECONNREFUSED') {
            this.errors.push(`‚ùå ${route.method} ${route.path} - Servidor no disponible`);
          } else {
            this.errors.push(`‚ùå ${route.method} ${route.path} - Error: ${error.message}`);
          }
        }
      } else {
        // Para rutas p√∫blicas
        try {
          const response = await axios(url, config);
          if (response.status >= 200 && response.status < 400) {
            console.log(`‚úÖ ${route.method} ${route.path} - OK (${response.status})`);
          } else {
            this.warnings.push(`‚ö†Ô∏è  ${route.method} ${route.path} - Status inesperado: ${response.status}`);
          }
        } catch (error) {
          if (error.code === 'ECONNREFUSED') {
            this.errors.push(`‚ùå ${route.method} ${route.path} - Servidor no disponible`);
          } else {
            this.errors.push(`‚ùå ${route.method} ${route.path} - Error: ${error.message}`);
          }
        }
      }
      
      this.validatedRoutes.add(`${route.method} ${route.path}`);
    } catch (error) {
      this.errors.push(`‚ùå Error validando ${route.method} ${route.path}: ${error.message}`);
    }
  }

  // üîç VALIDAR ARCHIVOS EST√ÅTICOS Y HTML
  async validateStaticFiles() {
    console.log('\nüîç Validando archivos est√°ticos...\n');
    
    const htmlFiles = [
      'index.html',
      'clients.html',
      'quotations.html',
      'followups.html',
      'plantillas.html',
      'respuestas.html',
      'contactos.html',
      'estadisticas.html',
      'integraciones.html',
      'soporte.html',
      'iapersonalizada.html',
      'conectar.html'
    ];

    const staticAssets = [
      'estilos.css',
      'tailwind.config.js',
      'client/public/favicon.ico',
      'client/public/manifest.json',
      'client/public/crm-info.html'
    ];

    // Validar archivos HTML
    for (const file of htmlFiles) {
      await this.validateFile(file, 'HTML');
    }

    // Validar assets est√°ticos
    for (const file of staticAssets) {
      await this.validateFile(file, 'ASSET');
    }
  }

  async validateFile(filePath, type) {
    try {
      if (fs.existsSync(filePath)) {
        console.log(`‚úÖ ${type}: ${filePath} - Existe`);
        this.staticFiles.add(filePath);
        
        if (type === 'HTML') {
          await this.validateHTMLContent(filePath);
        }
      } else {
        this.errors.push(`‚ùå ${type}: ${filePath} - Archivo no encontrado`);
      }
    } catch (error) {
      this.errors.push(`‚ùå Error validando ${filePath}: ${error.message}`);
    }
  }

  async validateHTMLContent(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      
      // Verificar enlaces internos
      const linkRegex = /href=["']([^"']+)["']/g;
      const scriptRegex = /src=["']([^"']+)["']/g;
      let match;

      // Validar enlaces href
      while ((match = linkRegex.exec(content)) !== null) {
        const link = match[1];
        if (this.isInternalLink(link)) {
          await this.validateInternalLink(link, filePath);
        }
      }

      // Validar scripts src
      while ((match = scriptRegex.exec(content)) !== null) {
        const src = match[1];
        if (this.isInternalResource(src)) {
          await this.validateInternalResource(src, filePath);
        }
      }
    } catch (error) {
      this.errors.push(`‚ùå Error leyendo contenido de ${filePath}: ${error.message}`);
    }
  }

  isInternalLink(link) {
    return !link.startsWith('http') && 
           !link.startsWith('mailto:') && 
           !link.startsWith('tel:') &&
           !link.startsWith('#') &&
           !link.startsWith('javascript:');
  }

  isInternalResource(src) {
    return !src.startsWith('http') && 
           !src.startsWith('//') &&
           !src.startsWith('data:');
  }

  async validateInternalLink(link, sourceFile) {
    const targetFile = link.startsWith('/') ? link.substring(1) : link;
    if (!fs.existsSync(targetFile)) {
      this.errors.push(`‚ùå Enlace roto en ${sourceFile}: ${link} -> ${targetFile}`);
    }
  }

  async validateInternalResource(src, sourceFile) {
    const targetFile = src.startsWith('/') ? src.substring(1) : src;
    if (!fs.existsSync(targetFile)) {
      this.warnings.push(`‚ö†Ô∏è  Recurso no encontrado en ${sourceFile}: ${src} -> ${targetFile}`);
    }
  }

  // üîç VALIDAR CONFIGURACI√ìN DEL SERVIDOR
  validateServerConfig() {
    console.log('\nüîç Validando configuraci√≥n del servidor...\n');
    
    const criticalFiles = [
      { path: 'index.js', type: 'Servidor principal' },
      { path: 'package.json', type: 'Configuraci√≥n NPM' },
      { path: '.env.example', type: 'Variables de entorno' },
      { path: 'config/database.js', type: 'Configuraci√≥n DB' },
      { path: 'models/index.js', type: 'Modelos Sequelize' }
    ];

    criticalFiles.forEach(file => {
      if (fs.existsSync(file.path)) {
        console.log(`‚úÖ ${file.type}: ${file.path} - OK`);
        this.validateFileContent(file.path, file.type);
      } else {
        this.errors.push(`‚ùå ${file.type}: ${file.path} - Archivo cr√≠tico faltante`);
      }
    });
  }

  validateFileContent(filePath, type) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      
      if (filePath === 'index.js') {
        // Verificar imports cr√≠ticos
        const criticalImports = [
          'express',
          'cors',
          'dotenv',
          './config/database',
          './models'
        ];
        
        criticalImports.forEach(imp => {
          if (!content.includes(imp)) {
            this.warnings.push(`‚ö†Ô∏è  ${filePath}: Posible import faltante - ${imp}`);
          }
        });

        // Verificar configuraci√≥n de puerto
        if (!content.includes('PORT') || !content.includes('listen')) {
          this.errors.push(`‚ùå ${filePath}: Configuraci√≥n de puerto faltante`);
        }
      }

      if (filePath === 'package.json') {
        try {
          const pkg = JSON.parse(content);
          if (!pkg.scripts || !pkg.scripts.start) {
            this.errors.push(`‚ùå ${filePath}: Script 'start' faltante`);
          }
          if (!pkg.dependencies || !pkg.dependencies.express) {
            this.errors.push(`‚ùå ${filePath}: Dependencia 'express' faltante`);
          }
        } catch (error) {
          this.errors.push(`‚ùå ${filePath}: JSON malformado`);
        }
      }
    } catch (error) {
      this.errors.push(`‚ùå Error leyendo ${filePath}: ${error.message}`);
    }
  }

  // üîç VALIDAR ESTRUCTURA DE DIRECTORIOS
  validateDirectoryStructure() {
    console.log('\nüîç Validando estructura de directorios...\n');
    
    const requiredDirs = [
      { path: 'config', desc: 'Configuraciones' },
      { path: 'models', desc: 'Modelos de datos' },
      { path: 'routes', desc: 'Rutas API' },
      { path: 'middleware', desc: 'Middlewares' },
      { path: 'controllers', desc: 'Controladores' },
      { path: 'client', desc: 'Frontend React' },
      { path: 'client/src', desc: 'C√≥digo fuente React' },
      { path: 'client/build', desc: 'Build de producci√≥n' }
    ];

    requiredDirs.forEach(dir => {
      if (fs.existsSync(dir.path) && fs.statSync(dir.path).isDirectory()) {
        console.log(`‚úÖ Directorio: ${dir.path} (${dir.desc}) - OK`);
      } else {
        this.warnings.push(`‚ö†Ô∏è  Directorio faltante: ${dir.path} (${dir.desc})`);
      }
    });
  }

  // üìä GENERAR REPORTE COMPLETO
  generateReport() {
    console.log('\n' + '='.repeat(60));
    console.log('üìä REPORTE COMPLETO DE VALIDACI√ìN CRM PROSELLER');
    console.log('='.repeat(60));
    
    console.log(`\nüîç ESTAD√çSTICAS:`);
    console.log(`   ‚Ä¢ Rutas API validadas: ${this.validatedRoutes.size}`);
    console.log(`   ‚Ä¢ Archivos est√°ticos encontrados: ${this.staticFiles.size}`);
    console.log(`   ‚Ä¢ Errores cr√≠ticos: ${this.errors.length}`);
    console.log(`   ‚Ä¢ Advertencias: ${this.warnings.length}`);

    if (this.errors.length > 0) {
      console.log(`\n‚ùå ERRORES CR√çTICOS (${this.errors.length}):`);
      this.errors.forEach((error, index) => {
        console.log(`   ${index + 1}. ${error}`);
      });
    }

    if (this.warnings.length > 0) {
      console.log(`\n‚ö†Ô∏è  ADVERTENCIAS (${this.warnings.length}):`);
      this.warnings.forEach((warning, index) => {
        console.log(`   ${index + 1}. ${warning}`);
      });
    }

    if (this.errors.length === 0 && this.warnings.length === 0) {
      console.log('\nüéâ ¬°EXCELENTE! No se encontraron problemas cr√≠ticos.');
      console.log('‚úÖ Tu CRM ProSeller est√° correctamente configurado.');
    } else if (this.errors.length === 0) {
      console.log('\n‚úÖ No hay errores cr√≠ticos, solo algunas advertencias menores.');
    } else {
      console.log('\nüö® Se encontraron errores que requieren atenci√≥n inmediata.');
    }

    console.log('\n' + '='.repeat(60));
    console.log('üîß RECOMENDACIONES:');
    console.log('   1. Corrige los errores cr√≠ticos primero');
    console.log('   2. Revisa las advertencias para optimizar');
    console.log('   3. Ejecuta este validador regularmente');
    console.log('   4. Mant√©n actualizada la documentaci√≥n');
    console.log('='.repeat(60));
  }

  // üöÄ EJECUTAR VALIDACI√ìN COMPLETA
  async runCompleteValidation() {
    console.log('üöÄ Iniciando validaci√≥n completa del CRM ProSeller...\n');
    
    try {
      // 1. Validar estructura de directorios
      this.validateDirectoryStructure();
      
      // 2. Validar configuraci√≥n del servidor
      this.validateServerConfig();
      
      // 3. Validar archivos est√°ticos
      await this.validateStaticFiles();
      
      // 4. Validar rutas API (requiere servidor corriendo)
      await this.validateAPIRoutes();
      
      // 5. Generar reporte final
      this.generateReport();
      
    } catch (error) {
      console.error('‚ùå Error durante la validaci√≥n:', error.message);
      this.errors.push(`Error general: ${error.message}`);
      this.generateReport();
    }
  }

  // üíæ GUARDAR REPORTE EN ARCHIVO
  saveReportToFile() {
    const reportData = {
      timestamp: new Date().toISOString(),
      stats: {
        validatedRoutes: this.validatedRoutes.size,
        staticFiles: this.staticFiles.size,
        errors: this.errors.length,
        warnings: this.warnings.length
      },
      errors: this.errors,
      warnings: this.warnings,
      validatedRoutes: Array.from(this.validatedRoutes),
      staticFiles: Array.from(this.staticFiles)
    };

    const fileName = `validation-report-${new Date().toISOString().slice(0, 10)}.json`;
    fs.writeFileSync(fileName, JSON.stringify(reportData, null, 2));
    console.log(`\nüíæ Reporte guardado en: ${fileName}`);
  }
}

// üéØ FUNCI√ìN PRINCIPAL DE EJECUCI√ìN
async function runValidation() {
  const validator = new CRMRouteValidator();
  await validator.runCompleteValidation();
  validator.saveReportToFile();
}

// Exportar para uso externo
module.exports = { CRMRouteValidator, runValidation };

// Ejecutar si se llama directamente
if (require.main === module) {
  runValidation().catch(console.error);
}
